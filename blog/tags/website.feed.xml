<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Ben Leskey's Blog: website</title>
		<description>website posts from Ben Leskey</description>
		<link>https://benleskey.com/blog/tags/website</link>
		<language>en-us</language>
		<copyright>2023 Ben Leskey</copyright>
		<lastBuildDate>Sat, 03 Jun 2023 17:51:20 +0000</lastBuildDate>
		<pubDate>Sat, 03 Jun 2023 17:51:20 +0000</pubDate>
		<atom:link href="https://benleskey.com/blog/tags/website.feed.xml" rel="self" type="application/rss+xml" />

		<item>
	<title>The Dillo Test</title>
	<description>&lt;div&gt;&lt;p&gt;You may not know what Dillo is.&lt;/p&gt;
&lt;img src=&quot;https://benleskey.com/blog/../images/dillo_test.png&quot; alt=&quot;benleskey.com in dillo&quot;&gt;

&lt;p&gt;That&#x27;s &lt;a href=&quot;https://www.dillo.org/&quot;&gt;Dillo&lt;/a&gt;. It&#x27;s a plain graphical web browser with minimal feature set beyond being able to draw text and, sometimes, images. Why would anyone want that? Well, there&#x27;s not much practical reason now&amp;#8212;every modern browser supports a truckload of features beyond simple HTML&amp;#8212;but it does indicate a simplicity and graceful degradation that is aesthetically desirable. This website, for instance, is entirely usable in Dillo. Javascript doesn&#x27;t work, but everything has a fallback. If your site works in Dillo, then it is &lt;i&gt;simple enough&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;It&#x27;s not even difficult to make this site work in Dillo. In fact, it avoids any kind of bloat. This site can&#x27;t rely on Javascript, or on complicated styling, or on anything but simple text to get its message across. Functionality beyond that is, as is traditional, just window dressing on top of a simple HTML structure. Common? No. But if your site works in Dillo it will probably satisfy the hacker hipsters.&lt;/p&gt;

&lt;p&gt;You can, of course, take it further and make the &lt;a href=&quot;https://lynx.invisible-island.net/&quot;&gt;Lynx&lt;/a&gt; test &lt;b&gt;;)&lt;/b&gt;. You&#x27;d better hope you&#x27;ve got alt text on your &lt;i&gt;img&lt;/i&gt; elements!&lt;/p&gt;

&lt;img src=&quot;https://benleskey.com/blog/../images/dillo_test_lynx.png&quot; alt=&quot;benleskey.com in lynx&quot;&gt;
&lt;/div&gt;</description>
	<category>dev</category><category>software</category><category>website</category>
	<link>https://benleskey.com/blog/dillo_test</link>
	<guid isPermaLink="true">https://benleskey.com/blog/dillo_test</guid>
	<pubDate>Thu, 11 May 2023 12:00:00 +0000</pubDate>
</item>
<item>
	<title>More RSS feeds!</title>
	<description>&lt;div&gt;&lt;p&gt;&lt;a href=&quot;https://benleskey.com/blog/../images/mappingtool_tag.png&quot;&gt;&lt;img class=&quot;right&quot; alt=&quot;mappingtool tag page&quot; src=&quot;https://benleskey.com/blog/../thumbs/mappingtool_tag.50.png&quot;&gt;&lt;/a&gt;I&#x27;ve added more RSS feeds, one for each blog tag. This allows people to subscribe to only, say, &lt;a href=&quot;https://benleskey.com/blog/tags/mappingtool&quot;&gt;the mappingtool tag&lt;/a&gt;. I can, in this way, use my blog easily as a set of smaller blogs for each category.&lt;/p&gt;

&lt;p&gt;This took just a bit of work in the website build script; and I cleaned it up a bit so it doesn&#x27;t commit temporary files and doesn&#x27;t need to work so hard to find the root of the website when I&#x27;m already passing that information in the script. I do need to refactor it more, it&#x27;s getting rather unwieldy, though still pretty simple to work with.&lt;/p&gt;
&lt;/div&gt;</description>
	<category>software</category><category>website</category>
	<link>https://benleskey.com/blog/more_rss_feeds</link>
	<guid isPermaLink="true">https://benleskey.com/blog/more_rss_feeds</guid>
	<pubDate>Fri, 27 Jan 2023 12:00:00 +0000</pubDate>
</item>
<item>
	<title>I&#x27;m on diff.blog</title>
	<description>&lt;div&gt;&lt;p&gt;
	&lt;img class=&quot;right&quot; alt=&quot;diffblogbot starring the linewriter1024.github.io repository&quot; src=&quot;https://benleskey.com/blog/../images/diff_blog_starred.png&quot;&gt;
	I saw yesterday that &lt;a href=&quot;https://diff.blog&quot;&gt;diff.blog&lt;/a&gt;&#x27;s bot account on Github had starred the repository for this website. I clicked through to their &lt;a href=&quot;https://github.com/diffblogbot&quot;&gt;Github page&lt;/a&gt;, which described diff.blog as &lt;q cite=&quot;https://github.com/diffblogbot&quot;&gt;an aggregator of developer blogs&amp;#8230; started in 2019 to improve the visibility of self hosted blogs&lt;/q&gt;.
	I followed the directions in their README and signed in to diff.blog with my Github account. Once there, I added the URL of &lt;a href=&quot;https://benleskey.com/blog/../blog&quot;&gt;my blog&lt;/a&gt; to my account settings and diff.blog crawled my RSS feed. Once I saw how it was using the RSS item descriptions to generate summaries, I improved my build script to actually generate a description instead of just a list of tags. Now my blog is fully functional on diff.blog!
&lt;/p&gt;

&lt;p&gt;
	&lt;a href=&quot;https://benleskey.com/blog/../images/diff_blog_plugin.png&quot;&gt;&lt;img class=&quot;right&quot; alt=&quot;diff.blog javascript plugin&quot; src=&quot;https://benleskey.com/blog/../thumbs/diff_blog_plugin.50.png&quot;&gt;&lt;/a&gt;
	diff.blog provides a Javascript &lt;a href=&quot;https://diff.blog/plugin&quot;&gt;plugin&lt;/a&gt; for blogs to display links to diff.blog, HN, and Reddit discussions about the post. I stuck this into my blog post template and it&#x27;s up and running without a hitch.
&lt;/p&gt;

&lt;p&gt;
	How did they find me? &lt;a href=&quot;https://github.com/diffblogbot&quot;&gt;diffblogbot&lt;/a&gt; seems to crawl Github looking for blogs like mine. Looking at a random sampling of their &lt;a href=&quot;https://github.com/diffblogbot?tab=stars&quot;&gt;stars&lt;/a&gt;, it seems that the crawled repositories are all Github Pages sites that either mention the keyword &quot;blog&quot; or have an RSS feed. Mine has both; I just &lt;a href=&quot;https://benleskey.com/blog/./made_rss_feed&quot;&gt;recently&lt;/a&gt; added the RSS feed.
&lt;/p&gt;

&lt;p&gt;
	What do I think? diff.blog doesn&#x27;t seem to be super popular, but it has a broad selection of independent blogs in its database and it interacts very well with my RSS feed. It was kinda cool to have them crawl my website unprompted. It doesn&#x27;t look like there will be any overhead for playing with diff.blog, unless the Javascript plugin stops working, but that&#x27;s easily stripped out. Maybe, with the fall of Twitter, services like this one will become more popular? Who knows.
&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://benleskey.com/blog/./finding_discussion_diff_blog&quot;&gt;I went looking for other discussion about diff.blog&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;</description>
	<category>software</category><category>website</category>
	<link>https://benleskey.com/blog/diff_blog</link>
	<guid isPermaLink="true">https://benleskey.com/blog/diff_blog</guid>
	<pubDate>Wed, 25 Jan 2023 12:00:00 +0000</pubDate>
</item>
<item>
	<title>I made an RSS feed!</title>
	<description>&lt;div&gt;&lt;p&gt;I made an &lt;a href=&quot;https://benleskey.com/blog/feed.xml&quot;&gt;RSS feed&lt;/a&gt; for my blog! It&#x27;s a really simple format; I was able to implement my feed just by following the &lt;a href=&quot;https://validator.w3.org/feed/docs/rss2.html&quot;&gt;RSS 2.0 spec&lt;/a&gt;. Of course, RSS readers are a little less common than they were a decade ago; but there are plenty of extensions for Firefox---I&#x27;m using &lt;a href=&quot;https://addons.mozilla.org/en-US/firefox/addon/rsspreview/&quot;&gt;RSSPreview&lt;/a&gt; just to test the feed---and with how easy it was to extend my blog generator to generate XML alongside HTML I figured it was better to have a feed than not.&lt;/p&gt;

&lt;img src=&quot;https://benleskey.com/blog/../images/cyberTOAD.jpg&quot; alt=&quot;Image of the cyberTOAD&amp;#8482;&quot;&gt;
&lt;/div&gt;</description>
	<category>software</category><category>website</category>
	<link>https://benleskey.com/blog/made_rss_feed</link>
	<guid isPermaLink="true">https://benleskey.com/blog/made_rss_feed</guid>
	<pubDate>Sun, 22 Jan 2023 12:00:00 +0000</pubDate>
</item>
<item>
	<title>benleskey.com build script</title>
	<description>&lt;div&gt;&lt;p&gt;
This website is static HTML, CSS, and Javascript. There is a build script that compiles together templates and HTML into the final website that you see, this bit of dynamicism enables me to reuse common HTML and keeps track of tedious bits like blog tag link lists. The script---as of writing---that compiles the website is fully commented and included below, along with the data file listing all the blog posts.
&lt;/p&gt;&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;https://benleskey.com/blog/#build&quot;&gt;build.sh&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;https://benleskey.com/blog/#posts&quot;&gt;posts.sh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2 id=&quot;build&quot;&gt;build.sh&lt;/h2&gt;
&lt;p&gt;
&lt;/p&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;
#!/bin/bash

# Akas are permanent names that redirect to various resources. If the location of the resource changes, the aka can simply be updated.
# Due to being hosted on Github pages we do not have direct control over redirects, so we must use meta refresh directives.
echo &quot;Akas...&quot;

# Each line in akas.txt has the format:
# &amp;lt;name of redirect&amp;gt; &amp;lt;url of redirect&amp;gt;
while read line; do
	# Split the aka line into the name and url
	name=&quot;$(echo &quot;$line&quot; | cut -d&#x27; &#x27; -f1)&quot;
	url=&quot;$(echo &quot;$line&quot; | cut -d&#x27; &#x27; -f2-)&quot;

	file=&quot;aka/$name.html&quot;

	echo &quot;&amp;lt;!DOCTYPE html&amp;gt;&quot; &amp;gt; $file
	echo &quot;&amp;lt;title&amp;gt;Redirecting to $url&amp;lt;/title&amp;gt;&quot; &amp;gt;&amp;gt; $file

	# Refresh the page immediately to the desired URL.
	echo &quot;&amp;lt;meta http-equiv=&#x27;refresh&#x27; content=&#x27;0; URL=$url&#x27;&amp;gt;&quot; &amp;gt;&amp;gt; $file

	# However, we don&#x27;t want any caching, so if we update the URL it will be immediately reflected in the redirect.
	echo &#x27;&amp;lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot; /&amp;gt;&#x27; &amp;gt;&amp;gt; $file
	echo &#x27;&amp;lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&amp;gt;&#x27; &amp;gt;&amp;gt; $file
	echo &#x27;&amp;lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&amp;gt;&#x27; &amp;gt;&amp;gt; $file

	# Additional links to the URL.
	echo &quot;&amp;lt;link rel=&#x27;canonical&#x27; href=&#x27;$url&#x27;&amp;gt;&quot; &amp;gt;&amp;gt; $file
	echo &quot;Redirecting to &amp;lt;a href=&#x27;$url&#x27;&amp;gt;$url&amp;lt;/a&amp;gt;...&quot; &amp;gt;&amp;gt; $file # The user can click this one if their browser doesn&#x27;t redirect them.

	echo &quot; Wrote $name -&amp;gt; $url&quot;
done &amp;lt; akas.txt

# replacetext &amp;lt;placeholder&amp;gt; &amp;lt;text to insert&amp;gt;
# A pipeline function to replace a placeholder with text
replacetext() {
	placeholder=&quot;$1&quot;
	text=&quot;$2&quot;

	sed &quot;s^$placeholder^$text^&quot;
}

# replacefile &amp;lt;placeholder&amp;gt; &amp;lt;path to file&amp;gt;
# A pipeline function to replace a placeholder with the contents of a file
replacefile() {
	placeholder=&quot;$1&quot;
	path=&quot;$2&quot;

	sed -e &quot;/$placeholder/r$path&quot; | sed &quot;s/$placeholder//g&quot;
}

# The list of all tags, to be built up as posts are processed.
alltags=&quot;&quot;

# Maximum blog posts in the &quot;minor&quot; list, i.e. on the front page.
BMMAX=3

# Number of blog posts so far.
BN=0

# The post function is called from the posts.sh list of posts; it is responsible for processing each blog post.
# A post has four components, reflected in the arguments:
# post &amp;lt;human-redable identifier name&amp;gt; &amp;lt;human-readable, pretty title of post&amp;gt; &amp;lt;date YYYY-MM-DD&amp;gt; &amp;lt;space-delimited list of tags&amp;gt;
post() {
	name=&quot;$1&quot;
	title=&quot;$2&quot;
	date=&quot;$3&quot;
	tags=&quot;$4&quot;

	# We&#x27;ll be reading the text of the blog post from an input HTML file and generating the full HTML page.
	infile=&quot;blog.in/$name.in.html&quot;
	outfile=&quot;blog/$name.html&quot;

	echo &quot; $name: $title [$date]&quot;

	# We will collect all the tags and build a list of hyperlinks to insert into the HTML.
	# HTML for the tag lists are generated for each different place they must be used with different styling and URLs (since sometimes we need blog/tags#tag and sometimes just tags/#tag if we are within the blog itself).

	taghtml=&quot;&quot; # The list of tags to be used within the blog posts.
	smalltaghtml=&quot;&quot; # The list of tags to be used within the &quot;major&quot; blog post list, on the dedicated blog page.
	minortaghtml=&quot;&quot; # The list of tags to be used within the &quot;minor&quot; blog post list, on the main page.

	while read tag; do
		taghtml=&quot;$taghtml &amp;lt;a class=&#x27;tag&#x27; href=&#x27;tags#$tag&#x27;&amp;gt;#$tag&amp;lt;/a&amp;gt;&quot;
		minortaghtml=&quot;$minortaghtml &amp;lt;a class=&#x27;smalltag&#x27; href=&#x27;blog/tags#$tag&#x27;&amp;gt;#$tag&amp;lt;/a&amp;gt;&quot;
		smalltaghtml=&quot;$smalltaghtml &amp;lt;a class=&#x27;smalltag&#x27; href=&#x27;tags#$tag&#x27;&amp;gt;#$tag&amp;lt;/a&amp;gt;&quot;

		# If we haven&#x27;t seen this tag yet in any post, record it and clear away any old file built from this tag.
		if ! echo &quot;$alltags&quot; | grep -w &quot;$tag&quot; &amp;gt; /dev/null; then
			echo &quot; New tag: $tag&quot;
			alltags=&quot;$alltags $tag&quot;
			rm -f &quot;blog/_tag_$tag.html&quot;
		fi

	done &amp;lt; &amp;lt;(echo &quot;$tags&quot; | xargs -n1)

	# Now we will write a link to this post to the each of its tags&#x27; pages.
	# We do this after tag processing because a link to the post also includes its tags, so we need to know all the tags of the post.
	while read tag; do
		echo &quot;&amp;lt;li class=&#x27;postlisting&#x27;&amp;gt;&amp;lt;a href=&#x27;$name&#x27;&amp;gt;$title&amp;lt;/a&amp;gt; [$date] $smalltaghtml&amp;lt;/li&amp;gt;&quot; &amp;gt;&amp;gt; &quot;blog/_tag_$tag.html&quot;
	done &amp;lt; &amp;lt;(echo &quot;$tags&quot; | xargs -n1)

	# Record that another post was processed.
	BN=$((BN+1))

	# If we haven&#x27;t reached the limit for &quot;minor&quot; posts, add a link to the minor blog post listing HTML, this is for the &quot;recent posts&quot; section of the main page.
	if [ $BN -le $BMMAX ]; then
		echo &quot;&amp;lt;li class=&#x27;postlisting&#x27;&amp;gt;&amp;lt;a href=&#x27;blog/$name&#x27;&amp;gt;$title&amp;lt;/a&amp;gt; [$date] $minortaghtml&amp;lt;/li&amp;gt;&quot; &amp;gt;&amp;gt; blog/_minor.in.html
	fi

	# Always add a link to the &quot;major&quot; blog post listing HTML, this is for the dedicated blog page.
	echo &quot;&amp;lt;li class=&#x27;postlisting&#x27;&amp;gt;&amp;lt;a href=&#x27;$name&#x27;&amp;gt;$title&amp;lt;/a&amp;gt; [$date] $smalltaghtml&amp;lt;/li&amp;gt;&quot; &amp;gt;&amp;gt; blog/_major.in.html

	# Build the blog post HTML.
	(replacetext &quot;__TITLE__&quot; &quot;$title&quot; | replacetext &quot;2023-06-03&quot; &quot;$date&quot; | replacetext &quot;__TAGS__&quot; &quot;$taghtml&quot; | replacefile &quot;__POST__&quot; &quot;$infile&quot;) &amp;lt; templates/post.in.html &amp;gt; &quot;$outfile&quot;
}

echo &quot;Blog...&quot;

# Begin the major and minor blog post lists.
echo &quot;&amp;lt;ul&amp;gt;&quot; &amp;gt; blog/_major.in.html
echo &quot;&amp;lt;ul&amp;gt;&quot; &amp;gt; blog/_minor.in.html

# Include the list of posts via source, so it can call the post function.
source blog.in/posts.sh

# If there are more posts than can be displayed in the minor list (on the main page) then add a &quot;More...&quot; link to the minor list.
if [ $BN -gt $BMMAX ]; then
	echo &quot;&amp;lt;li&amp;gt;&amp;lt;a href=&#x27;blog&#x27;&amp;gt;$((BN - BMMAX)) more...&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&quot; &amp;gt;&amp;gt; blog/_minor.in.html
fi

# Cap off the lists.
echo &quot;&amp;lt;/ul&amp;gt;&quot; &amp;gt;&amp;gt; blog/_minor.in.html
echo &quot;&amp;lt;/ul&amp;gt;&quot; &amp;gt;&amp;gt; blog/_major.in.html

# Build the main page.
(
	replacefile &quot;__BLOGMINOR__&quot; &quot;blog/_minor.in.html&quot; |
	# The date of generation is included on the main page.
	replacetext &quot;2023-06-03&quot; &quot;$(TZ=UTC date -I)&quot;
) &amp;lt; templates/index.in.html &amp;gt; index.html

# Build the dedicated blog index page.
(replacefile &quot;__BLOGMAJOR__&quot; &quot;blog/_major.in.html&quot;) &amp;lt; templates/blog.in.html &amp;gt; blog/index.html


# Uniquify and sort the list of all tags.
alltags=&quot;$(echo &quot;$alltags&quot; | xargs -n1 | sort | uniq | xargs)&quot;

# The tag index page consist of all the tags with every post categorized under their tag/tags.
echo &amp;gt; blog/_tags.in.html

# For each tag, just append the previously generated list of posts HTML for that tag.
while read tag; do
	echo &quot;&amp;lt;h1&amp;gt;$tag&amp;lt;/h1&amp;gt;&quot; &amp;gt;&amp;gt; blog/_tags.in.html
	echo &quot;&amp;lt;ul&amp;gt;&quot; &amp;gt;&amp;gt; blog/_tags.in.html
	cat &quot;blog/_tag_$tag.html&quot; &amp;gt;&amp;gt; blog/_tags.in.html
	echo &quot;&amp;lt;/ul&amp;gt;&quot; &amp;gt;&amp;gt; blog/_tags.in.html
done &amp;lt; &amp;lt;(echo &quot;$alltags&quot; | xargs -n1)

# Generate the full tag index page.
(replacefile &quot;__TAGS__&quot; &quot;blog/_tags.in.html&quot;) &amp;lt; templates/tags.in.html &amp;gt; blog/tags.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;

&lt;/p&gt;&lt;h2 id=&quot;posts&quot;&gt;posts.sh&lt;/h2&gt;
&lt;p&gt;
&lt;/p&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;
post website_build_script &quot;benleskey.com build script&quot; 2023-01-12 &quot;software website&quot;
post mapper0_4 &quot;Mapping tool 0.4 release&quot; 2023-01-04 &quot;mappingtool software&quot;
post mapper0_3 &quot;Mapping tool 0.3 release&quot; 2022-10-26 &quot;mappingtool software&quot;
post mapper0_1 &quot;Mapping tool 0.1 release&quot; 2022-08-01 &quot;mappingtool software&quot;
&lt;/code&gt;
&lt;/pre&gt;

&lt;/div&gt;</description>
	<category>software</category><category>website</category>
	<link>https://benleskey.com/blog/website_build_script</link>
	<guid isPermaLink="true">https://benleskey.com/blog/website_build_script</guid>
	<pubDate>Thu, 12 Jan 2023 12:00:00 +0000</pubDate>
</item>_
	</channel>
</rss>
